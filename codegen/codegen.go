package main

import (
	"bufio"
	"fmt"
	"log"
	"net/http"
	"os"
	"regexp"
	"strings"
)

func main() {
	// Check if the version argument is provided
	if len(os.Args) < 2 {
		// If not, print an error message and exit
		fmt.Println("Error: Missing version argument")
		os.Exit(1)
	}

	// Get the version argument from the command line
	version := os.Args[1]

	// Construct the URL for the emoji test data based on the version
	url := fmt.Sprintf("https://unicode.org/Public/emoji/%s/emoji-test.txt", version)

	// Fetch the emoji test data from the Unicode website
	resp, err := http.Get(url)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()

	// Create a new scanner to read the response body line by line
	scanner := bufio.NewScanner(resp.Body)

	// Create a new file to write the emoji list to
	versionClean := "v"
	zeroPatch := strings.HasSuffix(version, ".0")
	if zeroPatch {
		versionClean += strings.TrimSuffix(version, ".0")

		if err := os.MkdirAll(versionClean, 0755); err != nil {
			log.Fatal(err)
		}
	} else {
		versionClean += strings.ReplaceAll(version, ".", "")
		if err := os.MkdirAll(fmt.Sprintf("v%s", version), 0755); err != nil {
			log.Fatal(err)
		}
	}

	var f *os.File

	if zeroPatch {
		f, err = os.Create(fmt.Sprintf("%s/%s.go", versionClean, versionClean))
	} else {
		f, err = os.Create(fmt.Sprintf("v%s/%s.go", version, versionClean))
	}
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close() // Close the file when the function returns

	// Write the package declaration and a warning not to edit the file to the new file
	fmt.Fprintln(f, fmt.Sprintf("//go:generate go run codegen/codegen.go %s", version))
	fmt.Fprintln(f, fmt.Sprintf("package %s", versionClean))
	fmt.Fprintln(f, "")
	fmt.Fprintln(f, "// THIS FILE IS GENERATED BY GO GENERATE. DO NOT EDIT.")
	fmt.Fprintln(f, "")

	// Compile a regular expression to match the lines containing emoji data
	// re := regexp.MustCompile(`^([0-9A-F ]+)\s+; fully-qualified\s+# (.*) E[0-9.]*\.?[0-9]* (.*)$`)
	re := regexp.MustCompile(`^([0-9A-F ]+)\s+; fully-qualified\s+# (.*?)(?: E[0-9.]*\.?[0-9]*)? (.*)$`)

	// Loop through each line in the response body
	for scanner.Scan() {
		line := scanner.Text()

		// Skip comment lines and empty lines
		if strings.HasPrefix(line, "#") || strings.TrimSpace(line) == "" {
			continue
		}

		// Try to match the line with the regular expression
		matches := re.FindStringSubmatch(line)

		// If the line matches the regular expression, extract the emoji character and name
		if len(matches) == 4 {
			emojiChar := matches[2]
			emojiName := matches[3]

			// Create a constant name for the emoji by converting the name to uppercase and replacing spaces and special characters with underscores
			constName := "EMOJI_" + strings.ToUpper(strings.ReplaceAll(emojiName, " - ", "_"))
			constName = strings.ReplaceAll(constName, " ", "_")
			constName = strings.ReplaceAll(constName, "-", "_")
			constName = strings.ReplaceAll(constName, ":", "")
			constName = strings.ReplaceAll(constName, ",", "")
			constName = strings.ReplaceAll(constName, "'", "")
			constName = strings.ReplaceAll(constName, "’", "")
			constName = strings.ReplaceAll(constName, "(", "")
			constName = strings.ReplaceAll(constName, ")", "")
			constName = strings.ReplaceAll(constName, ".", "")
			constName = strings.ReplaceAll(constName, "!", "")
			constName = strings.ReplaceAll(constName, "“", "")
			constName = strings.ReplaceAll(constName, "”", "")
			constName = strings.ReplaceAll(constName, "#", "HASHTAG")
			constName = strings.ReplaceAll(constName, "*", "STAR")
			constName = strings.ReplaceAll(constName, "&", "AND")

			// Write the constant declaration to the new file
			fmt.Fprintf(f, "const %s = \"%s\"\n", constName, emojiChar)
		}
	}

	// Check for any errors that occurred while scanning the response body
	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}
}
